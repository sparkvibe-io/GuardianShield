{
  "name": "guardianshield",
  "version": "1.1.0b1",
  "displayName": "GuardianShield",
  "description": "Universal AI security layer â€” code scanning, PII detection, prompt injection defense, secret detection, dependency auditing, and audit logging.",
  "homepage": "https://github.com/sparkvibe-io/GuardianShield",
  "repository": "https://github.com/sparkvibe-io/GuardianShield",
  "documentation": "https://sparkvibe-io.github.io/GuardianShield/",
  "icon": "https://raw.githubusercontent.com/sparkvibe-io/GuardianShield/main/docs/assets/logo.png",
  "license": "Apache-2.0",
  "runtime": "python",
  "transport": ["stdio"],
  "package": {
    "registry": "pypi",
    "name": "guardianshield",
    "version": "1.1.0b1",
    "command": "guardianshield-mcp"
  },
  "tools": [
    {
      "name": "scan_code",
      "description": "Scan source code for security vulnerabilities (SQL injection, XSS, command injection, path traversal) and hardcoded secrets/credentials. Returns a list of findings with severity, type, and remediation guidance.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "code": { "type": "string", "description": "The source code to scan." },
          "file_path": { "type": "string", "description": "Optional file path for context in findings." },
          "language": { "type": "string", "description": "Optional programming language hint." },
          "engines": { "type": "array", "items": { "type": "string" }, "description": "Optional list of engine names to use for this scan." }
        },
        "required": ["code"]
      }
    },
    {
      "name": "scan_input",
      "description": "Check user or agent input for prompt injection attempts. Detects instruction override, role hijacking, system prompt extraction, delimiter abuse, ChatML injection, jailbreak keywords, and encoding evasion.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "text": { "type": "string", "description": "The input text to check for injection attempts." }
        },
        "required": ["text"]
      }
    },
    {
      "name": "scan_output",
      "description": "Check AI-generated output for PII leaks (email, SSN, credit card, phone, IP) and content policy violations (violence, self-harm, illegal activity). PII is automatically redacted in findings.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "text": { "type": "string", "description": "The AI output text to scan." }
        },
        "required": ["text"]
      }
    },
    {
      "name": "check_secrets",
      "description": "Dedicated secret and credential detection. Scans text for AWS keys, GitHub tokens, Stripe keys, private keys, JWTs, Slack tokens, passwords, connection strings, Google API keys, and more. All matched secrets are redacted in findings.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "text": { "type": "string", "description": "The text to scan for secrets." },
          "file_path": { "type": "string", "description": "Optional file path for context." }
        },
        "required": ["text"]
      }
    },
    {
      "name": "get_profile",
      "description": "Get the current safety profile configuration including scanner settings and blocked content categories.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "set_profile",
      "description": "Switch to a different safety profile. Available profiles: general, education, healthcare, finance, children. Each profile adjusts scanner sensitivity and blocked categories.",
      "annotations": {
        "readOnlyHint": false,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "name": { "type": "string", "description": "Profile name to activate.", "enum": ["general", "education", "healthcare", "finance", "children"] }
        },
        "required": ["name"]
      }
    },
    {
      "name": "audit_log",
      "description": "Query the security audit log. Returns recent scan events with timestamps, scan types, finding counts, and input hashes.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "scan_type": { "type": "string", "description": "Filter by scan type.", "enum": ["code", "input", "output", "secrets", "dependencies", "directory_dependencies"] },
          "limit": { "type": "integer", "description": "Maximum number of entries to return (default 50).", "minimum": 1, "maximum": 500 }
        }
      }
    },
    {
      "name": "get_findings",
      "description": "Retrieve past security findings from the audit database with optional filters by type, severity, or audit ID.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "audit_id": { "type": "integer", "description": "Filter findings by audit log entry ID." },
          "finding_type": { "type": "string", "description": "Filter by finding type (e.g. secret, sql_injection, pii_leak)." },
          "severity": { "type": "string", "description": "Filter by severity level.", "enum": ["critical", "high", "medium", "low", "info"] },
          "limit": { "type": "integer", "description": "Maximum findings to return (default 100).", "minimum": 1, "maximum": 1000 }
        }
      }
    },
    {
      "name": "shield_status",
      "description": "Get GuardianShield health and configuration status including active profile, enabled scanners, and audit statistics.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "scan_file",
      "description": "Scan a single source file for vulnerabilities and secrets. Auto-detects language from file extension. Returns findings with line numbers, severity, CWE IDs, and remediation.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "path": { "type": "string", "description": "Absolute or relative path to the file." },
          "language": { "type": "string", "description": "Optional language hint (auto-detected from extension)." }
        },
        "required": ["path"]
      }
    },
    {
      "name": "scan_directory",
      "description": "Recursively scan a directory for vulnerabilities and secrets. Supports extension filtering, exclude patterns, and reports progress. Returns all findings across all scanned files.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "path": { "type": "string", "description": "Root directory to scan." },
          "extensions": { "type": "array", "items": { "type": "string" }, "description": "File extensions to include (e.g. [\".py\", \".js\"])." },
          "exclude": { "type": "array", "items": { "type": "string" }, "description": "Glob patterns to skip (e.g. [\"node_modules/*\"])." }
        },
        "required": ["path"]
      }
    },
    {
      "name": "test_pattern",
      "description": "Test a regex pattern against sample code. Returns match details including positions and matched text. Useful for developing and debugging custom vulnerability patterns.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "regex": { "type": "string", "description": "The regex pattern to test." },
          "sample": { "type": "string", "description": "Sample code to test against." },
          "language": { "type": "string", "description": "Optional language context for the pattern." }
        },
        "required": ["regex", "sample"]
      }
    },
    {
      "name": "check_dependencies",
      "description": "Check package dependencies for known vulnerabilities using the OSV.dev database. Provide a list of packages with names, versions, and ecosystems (PyPI or npm).",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": true
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "dependencies": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "name": { "type": "string", "description": "Package name (e.g. 'requests', 'express')." },
                "version": { "type": "string", "description": "Package version (e.g. '2.28.0', '4.18.2')." },
                "ecosystem": { "type": "string", "description": "Package ecosystem.", "enum": ["PyPI", "npm", "Go", "Packagist"], "default": "PyPI" }
              },
              "required": ["name", "version"]
            },
            "description": "List of dependencies to check."
          }
        },
        "required": ["dependencies"]
      }
    },
    {
      "name": "sync_vulnerabilities",
      "description": "Sync the local OSV vulnerability database for a given ecosystem. Call this to update the cache before checking dependencies.",
      "annotations": {
        "readOnlyHint": false,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": true
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "ecosystem": { "type": "string", "description": "Ecosystem to sync (PyPI, npm, Go, or Packagist).", "enum": ["PyPI", "npm", "Go", "Packagist"] },
          "packages": { "type": "array", "items": { "type": "string" }, "description": "Optional list of package names to sync." }
        },
        "required": ["ecosystem"]
      }
    },
    {
      "name": "parse_manifest",
      "description": "Parse a dependency manifest file into a structured list of dependencies. Auto-detects format from the filename. Supports: requirements.txt, package.json, pyproject.toml, package-lock.json, yarn.lock, pnpm-lock.yaml, Pipfile.lock, go.mod, go.sum, composer.json, composer.lock.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "content": { "type": "string", "description": "The contents of the manifest file." },
          "filename": { "type": "string", "description": "Filename for format detection (e.g. 'requirements.txt', 'package.json', 'package-lock.json', 'yarn.lock', 'go.mod', 'composer.json')." }
        },
        "required": ["content", "filename"]
      }
    },
    {
      "name": "scan_dependencies",
      "description": "Recursively scan a directory for manifest/lockfiles (requirements.txt, package.json, go.mod, composer.json, etc.), parse dependencies, and check them for known vulnerabilities using the OSV.dev database.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": true
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "path": { "type": "string", "description": "Root directory to scan for manifest files." },
          "exclude": { "type": "array", "items": { "type": "string" }, "description": "Glob patterns to skip (e.g. [\"vendor/*\"])." }
        },
        "required": ["path"]
      }
    },
    {
      "name": "mark_false_positive",
      "description": "Mark a security finding as a false positive. The finding will be flagged in future scans, and similar patterns at other locations will be annotated as potential false positives.",
      "annotations": {
        "readOnlyHint": false,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "finding": { "type": "object", "description": "The finding dict as returned by a scan tool." },
          "reason": { "type": "string", "description": "Optional explanation of why this is a false positive." }
        },
        "required": ["finding"]
      }
    },
    {
      "name": "list_false_positives",
      "description": "List active false positive records. Shows findings that have been marked as false positives, with optional filtering by scanner.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "scanner": { "type": "string", "description": "Optional filter by scanner name (e.g. 'code_scanner', 'secrets')." },
          "limit": { "type": "integer", "description": "Maximum number of records to return (default 100).", "minimum": 1, "maximum": 500 }
        }
      }
    },
    {
      "name": "unmark_false_positive",
      "description": "Remove a false positive record by its fingerprint. The finding will no longer be flagged in future scans.",
      "annotations": {
        "readOnlyHint": false,
        "destructiveHint": true,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "fingerprint": { "type": "string", "description": "The fingerprint of the false positive record to remove." }
        },
        "required": ["fingerprint"]
      }
    },
    {
      "name": "list_engines",
      "description": "List available analysis engines with their capabilities and enabled status. Returns each engine's name, whether it is enabled in the current profile, and its capabilities.",
      "annotations": {
        "readOnlyHint": true,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "set_engine",
      "description": "Set which analysis engines are active for code scanning. Accepts a list of engine names to enable for the current session. Available engines can be listed with list_engines.",
      "annotations": {
        "readOnlyHint": false,
        "destructiveHint": false,
        "idempotentHint": true,
        "openWorldHint": false
      },
      "inputSchema": {
        "type": "object",
        "properties": {
          "engines": { "type": "array", "items": { "type": "string" }, "description": "List of engine names to enable." }
        },
        "required": ["engines"]
      }
    }
  ],
  "prompts": [
    {
      "name": "security-review",
      "description": "Perform a comprehensive security review of code. Scans for vulnerabilities, secrets, and provides remediation guidance.",
      "arguments": [
        { "name": "code", "description": "The source code to review.", "required": true },
        { "name": "file_path", "description": "Optional file path for context.", "required": false }
      ]
    },
    {
      "name": "compliance-check",
      "description": "Check text for compliance with the active safety profile. Scans for PII, content violations, and policy adherence.",
      "arguments": [
        { "name": "text", "description": "The text to check for compliance.", "required": true }
      ]
    }
  ]
}
